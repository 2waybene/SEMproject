library(doMC)
num.of.core <-  multicore:::detectCores()
registerDoMC(num.of.core)
##================================================
#  cl <- makeCluster(2, type="SOCK")
#  cl <- makeCluster(16, type="SOCK")
ptime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %dopar% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
cat(sprintf('Parallel time using doMC on %d workers: %f\n',
num.of.core, ptime))
stime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %do% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
cat(sprintf('Sequential time: %f\n', stime))
cat(sprintf('Speed up for %d workers: %f\n',
num.of.core, round(stime / ptime, digits=2)))
}
if( Sys.info()[['sysname']] == 'Darwin' ){
message(paste(
"\n",
"   *** MacOS detected ***\n",
"   \n",
"   Use doMC package for multicore ability\n\n"))
}else if ( Sys.info()[['sysname']] == 'Linux' ){
message(paste(
"\n",
"   *** Linux detected ***\n",
"   \n",
"   Use doMC package for multicore ability\n\n"))
}else if ( Sys.info()[['sysname']] ==  'Windows'  ){
message(paste(
"\n",
"   *** Windows detected ***\n",
"   Use doMC package will NOT work for multicore ability\n",
"   You may consider using doSNOW instead \n\n"))
}else{
message(paste(
"\n",
"   You may want to check your computer's operation syste\n",
"   it might come from the Extra Terrestrian \n\n"))
}
library(doMC)
multicore:::detectCores()
detectCores()
##=================================
##  multiCore_CrossPlatforms.R
##  Author: Jianying Li
##=================================
##================================================
##  Windows, use doParallel package
##================================================
if( Sys.info()[['sysname']] == 'Windows' ){
message(paste(
"\n",
"   *** Microsoft Windows detected ***\n",
"   \n",
"   Use doSNOW package for multicore ability\n\n"))
x <- iris[which(iris[,5] != "setosa"), c(1,5)]
trials <- 10000
library(doParallel)
number.of.workers <- max (1, (detectCores() - 4))
cl <- makeCluster(number.of.workers, type='PSOCK')
registerDoParallel(cl)
ptime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %dopar% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
registerDoSEQ()
stime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %do% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
cat(sprintf('Sequential time: %f\n', stime))
cat(sprintf('Speed up for %d workers: %f\n',
number.of.workers, round(stime / ptime, digits=2)))
}
##================================================
##  Linux,
##  use doMC package
##  doParalell also works under Linux but not
##  as good as doMC
##================================================
if( Sys.info()[['sysname']] == 'Linux' ){
message(paste(
"\n",
"   *** Linux detected ***\n",
"   \n",
"   Use doMC package for multicore ability\n\n"))
x <- iris[which(iris[,5] != "setosa"), c(1,5)]
trials <- 10000
library(doMC)
num.of.core <-  multicore:::detectCores()
registerDoMC(num.of.core)
ptime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %dopar% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
cat(sprintf('Parallel time using doMC on %d workers: %f\n',
num.of.core, ptime))
stime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %do% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
cat(sprintf('Sequential time: %f\n', stime))
cat(sprintf('Speed up for %d workers: %f\n',
getDoParWorkers(), round(stime / ptime, digits=2)))
}
##================================================
##  MacOS
##  Will test both packages: doSNOW vs. doMC
##================================================
if( Sys.info()[['sysname']] == 'Darwin' ){
message(paste(
"\n",
"   *** MacOS detected ***\n",
"   \n",
"   Use doMC package for multicore ability\n\n"))
library(doMC)
num.of.core <-  detectCores()
registerDoMC(num.of.core)
##================================================
#  cl <- makeCluster(2, type="SOCK")
#  cl <- makeCluster(16, type="SOCK")
ptime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %dopar% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
cat(sprintf('Parallel time using doMC on %d workers: %f\n',
num.of.core, ptime))
stime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %do% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
cat(sprintf('Sequential time: %f\n', stime))
cat(sprintf('Speed up for %d workers: %f\n',
num.of.core, round(stime / ptime, digits=2)))
}
##=================================
##  multiCore_CrossPlatforms.R
##  Author: Jianying Li
##=================================
##================================================
##  Windows, use doParallel package
##================================================
if( Sys.info()[['sysname']] == 'Windows' ){
message(paste(
"\n",
"   *** Microsoft Windows detected ***\n",
"   \n",
"   Use doSNOW package for multicore ability\n\n"))
x <- iris[which(iris[,5] != "setosa"), c(1,5)]
trials <- 10000
library(doParallel)
number.of.workers <- max (1, (detectCores() - 4))
cl <- makeCluster(number.of.workers, type='PSOCK')
registerDoParallel(cl)
ptime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %dopar% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
registerDoSEQ()
stime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %do% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
cat(sprintf('Sequential time: %f\n', stime))
cat(sprintf('Speed up for %d workers: %f\n',
number.of.workers, round(stime / ptime, digits=2)))
}
##================================================
##  Linux,
##  use doMC package
##  doParalell also works under Linux but not
##  as good as doMC
##================================================
if( Sys.info()[['sysname']] == 'Linux' ){
message(paste(
"\n",
"   *** Linux detected ***\n",
"   \n",
"   Use doMC package for multicore ability\n\n"))
x <- iris[which(iris[,5] != "setosa"), c(1,5)]
trials <- 10000
library(doMC)
num.of.core <-  multicore:::detectCores()
registerDoMC(num.of.core)
ptime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %dopar% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
cat(sprintf('Parallel time using doMC on %d workers: %f\n',
num.of.core, ptime))
stime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %do% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
cat(sprintf('Sequential time: %f\n', stime))
cat(sprintf('Speed up for %d workers: %f\n',
getDoParWorkers(), round(stime / ptime, digits=2)))
}
##================================================
##  MacOS
##  Will test both packages: doSNOW vs. doMC
##================================================
if( Sys.info()[['sysname']] == 'Darwin' ){
message(paste(
"\n",
"   *** MacOS detected ***\n",
"   \n",
"   Use doMC package for multicore ability\n\n"))
x <- iris[which(iris[,5] != "setosa"), c(1,5)]
trials <- 10000
library(doMC)
num.of.core <-  detectCores()
registerDoMC(num.of.core)
##================================================
#  cl <- makeCluster(2, type="SOCK")
#  cl <- makeCluster(16, type="SOCK")
ptime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %dopar% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
cat(sprintf('Parallel time using doMC on %d workers: %f\n',
num.of.core, ptime))
stime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %do% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
cat(sprintf('Sequential time: %f\n', stime))
cat(sprintf('Speed up for %d workers: %f\n',
num.of.core, round(stime / ptime, digits=2)))
}
library(doParallel)
number.of.workers <- detectCores()
cl <- makeCluster(number.of.workers, type='PSOCK')
registerDoParallel(cl)
ptime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %dopar% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
registerDoSEQ()
cat(sprintf('Parallel time using doMC on %d workers: %f\n',
num.of.core, ptime))
stime <- system.time({
r <- foreach(icount(trials), .combine=cbind) %do% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
})[3]
cat(sprintf('Sequential time: %f\n', stime))
cat(sprintf('Speed up for %d workers: %f\n',
number.of.workers, round(stime / ptime, digits=2)))
runApp('myGit/STARTapp')
runApp('myGit/WorldCloud')
runApp('myGit/myOCRI-iii/shinyapp/OCRI3')
runApp('myGit/myOCRI-iii/shinyapp/OCRI3')
runApp('myGit/myOCRI-iii/shinyapp/OCRI3')
runApp('Desktop/SigGen')
runApp('myGit/WorldCloud')
runApp('Desktop/SigGen')
450000*655
library(pvca)
install.packages("pvca")
source("https://bioconductor.org/biocLite.R")
biocLite("pvca")
library(pvca)
sessionInfo()
51441/76
51441/76.5
51441/76.3
51441/76.1
51441/77
51441/76.5
library(sem)
#Loehlin problem 2.5
obs.var2.5 = c('Ach1',  'Ach2',  'Amb1',  'Amb2',  'Amb3')
R.prob2.5 = matrix(c(
1.00 ,  .60  , .30,  .20,   .20,
.60,  1.00,   .20,   .30,   .10,
.30,   .20,  1.00,   .70,   .60 ,
.20,   .30,   .70,  1.00,   .50,
.20,   .10,   .60,  .50,  1.00), ncol=5,byrow=TRUE)
#correlated factors structure (ambition <-> Achievement)
model2.5=matrix(c(
'Ambit ->  Amb1',      'a', NA,
'Ambit -> Amb2' ,      'b', NA,
'Ambit -> Amb3' ,      'c', NA,
'Achieve -> Ach1',     'd', NA,
'Achieve -> Ach2',     'e', NA,
'Ambit <-> Achieve',   'f', NA,
'Amb1 <-> Amb1' ,      'u', NA,
'Amb2 <-> Amb2' ,      'v', NA,
'Amb3 <-> Amb3' ,      'w', NA,
'Ach1 <-> Ach1' ,      'x', NA,
'Ach2 <-> Ach2' ,      'y', NA,
'Achieve <-> Achieve',  NA, 1,
'Ambit <-> Ambit',      NA, 1),
ncol=3, byrow=TRUE)
sem2.5= sem(model2.5,  R.prob2.5, 60, obs.var2.5)
summary(sem2.5,digits=3)
model2.5
R.prob2.5
obs.var2.5
sem2.5= sem(model2.5,  R.prob2.5, 60, obs.var2.5)
library(gSEM)
install.packages("gSEM")
library(gSEM)
data(acrylic)
ans <- sgSEMp1(acrylic, predictor = "IrradTot", response = "YI")
cf <- path(ans, from = "IrradTot", to = "IAD2")
print(cf)
plot(ans, cutoff = 0.1)
acrylic
model2.5
sem2.5= sem(model2.5,  R.prob2.5, 60, obs.var2.5)
sem
model.dhp.1 <- specifyEquations(covs="RGenAsp, FGenAsp")
R.bd <- readMoments(names=c("x1", "x2", "y3", "y4", "y5"))
R.bd <- readMoments(names=c("x1", "x2", "y3", "y4", "y5"))
y3 <- x1, gam31
R.bd <- readMoments(names=c("x1", "x2", "y3", "y4", "y5"))
mod.bd <- specifyModel()
mod.bd <- specifyModel()
sem.bd <- sem(mod.bd, R.bd, N=20700, fixed.x=c("x1", "x2"))
summary(sem.bd)
effects(sem.bd)
obs.var2.5 = c('Ach1',  'Ach2',  'Amb1',  'Amb2',  'Amb3')
R.prob2.5 = matrix(c(
1.00 ,  .60  , .30,  .20,   .20,
.60,  1.00,   .20,   .30,   .10,
.30,   .20,  1.00,   .70,   .60 ,
.20,   .30,   .70,  1.00,   .50,
.20,   .10,   .60,  .50,  1.00), ncol=5,byrow=TRUE)
model2.5=matrix(c(
'Ambit ->  Amb1',      'a', NA,
'Ambit -> Amb2' ,      'b', NA,
'Ambit -> Amb3' ,      'c', NA,
'Achieve -> Ach1',     'd', NA,
'Achieve -> Ach2',     'e', NA,
'Ambit <-> Achieve',   'f', NA,
'Amb1 <-> Amb1' ,      'u', NA,
'Amb2 <-> Amb2' ,      'v', NA,
'Amb3 <-> Amb3' ,      'w', NA,
'Ach1 <-> Ach1' ,      'x', NA,
'Ach2 <-> Ach2' ,      'y', NA,
'Achieve <-> Achieve',  NA, 1,
'Ambit <-> Ambit',      NA, 1),
ncol=3, byrow=TRUE)
sem2.5= sem(model2.5,  R.prob2.5, 60, obs.var2.5)
setwd("~/myGit/SEMproject/RSV_association_study/study_with_IFNAR1/")
source ("analysisFuncs.R")
load("SNP_file_BPIIFA1_to_MYD88.rda")
load("clinic_dt.rda")
SNP_ifnar1 = "seq.rs2257167"
column2use = which(colnames(sheetIN) %in% SNP_ifnar1)
snp.name = SNP_ifnar1
#column2use
SAT_phenotype_col =  6
#snp.name <- colnames(sheetIN)[column2use]
#snp.name
geno.pheno <- cbind(sheetIN[,column2use], dt[,SAT_phenotype_col])
geno.pheno <- as.data.frame(geno.pheno)
##==================================================
##  This is VERY important that for now we HAVE TO
##  flip the genotype coding!
##  Genotyp coding scema:
##                0 : homozygous reference allele
##                1 : heterozygous ref/SNP
##                2 : homozygous variant allele
##==================================================
geno.pheno[,1] <-  abs (geno.pheno[,1] - 2)
table (geno.pheno[,1])
#0   1   2
#396 286  55
##====================================================
##  OKAY, from now on, we can proceed with the study
##====================================================
colnames(geno.pheno) <- c ("SNP", "SAT")
rownames(geno.pheno) <- dt$RSV.ID
##  Here, we are looking at all the SNP
##  regardless of RSV infection status
data_all <- geno.pheno
#str(dt$RSV.ID)
#str(geno.pheno)
##  ONLY use RSV positive for the following analyses!!
row2use <-  which(dt$RSV == 1)
geno.pheno <- geno.pheno [row2use ,]
cov.dt <- dt[row2use ,]
##  Exclude individual with missing SNP information
if (length(which(is.na(geno.pheno[,1]))) > 0) {
missing.row = which(is.na(geno.pheno[,1]))
geno.pheno <-  geno.pheno[-missing.row,]
cov.dt <- cov.dt[-missing.row ,]
}
str(geno.pheno)
str(cov.dt)
# 1 For all SNP/indivudual
d1 <- as.data.frame(table (data_all[,1]))
REFF <- (d1$Freq[1]*2 + d1$Freq[2])/(sum(d1$Freq)*2)
VARF <- (d1$Freq[3]*2 + d1$Freq[2])/(sum(d1$Freq)*2)
case.1 <- c(REFF , VARF )
# 2 SNP from indivudual with RSV positive
d2 <- as.data.frame(table (geno.pheno[,1]))
REFF2 <- (d2$Freq[1]*2 + d2$Freq[2])/(sum(d2$Freq)*2)
VARF2 <- (d2$Freq[3]*2 + d2$Freq[2])/(sum(d2$Freq)*2)
case.2 <- c(REFF2 , VARF2 )
snp.freq <- as.data.frame (rbind (case.1, case.2))
colnames (snp.freq) <- c("Reference allele (G) frequency", "Variant allele (C) frequency")
rownames (snp.freq) <- c("ALL individual", "Individual with RSV positive")
snp.freq
table(geno.pheno)
table (geno.pheno[,1])
m <- as.data.frame(geno.pheno)
summary(glm(m[,2] ~ m[,1], family=binomial("logit")))
summary(glm(m[,2] ~ as.factor(m[,1]), family=binomial("logit")))
counts  <- as.matrix(table (m))
chisq.test(counts)
library(multiCA)
multiCA.test(counts)
qchisq(.95, df=7)
qchisq(1-(0.004097), df=2)
pchisq(10.995, df=2)
1-pchisq(10.995, df=2)
1-pchisq(10.995, df=1)
multiCA.test(t(counts))
1-pchisq(10.167, df=1)
table(geno.pheno[,1])
m2 <- as.data.frame(geno.pheno)
m2[which(m2[,1] == 2),1] = 1
table (m2[,1])
m2.logistic= glm(m2[,2] ~ m2[,1], family=binomial("logit"))
m2.logistic= glm(m2[,2] ~ as.factor(m2[,1]), family=binomial("logit"))
summary(glm(m2[,2] ~ m2[,1], family=binomial("logit")))
summary(glm(m2[,2] ~ as.factor(m2[,1]), family=binomial("logit")))
exp(summary(m2.logistic)$coefficients[2,1])
exp(summary(m2.logistic)$coefficients[2,1] +  qnorm(c(0.025,0.5,0.975)) *summary(m2.logistic)$coefficients[2,2])
sample(c(0,1),100, replace=T)
x=sample(c(0,1),100, replace=T)
y=sample(c(0,1),100, replace=T)
x
y
xytab=table(x,y)
xytab
set.seed(1234567)
x=sample(c(0,1),100, replace=T)
y=sample(c(0,1),100, replace=T)
##create a 2x2 table with counts
xytab=table(x,y)
xytab
xytab[,2]
xytab[,1]
count=cbind(xytab[,2],xytab[,1])
count
xfactor=factor(c("0","1"))
xfactor
xfactor
tmp3=glm(count ~ xfactor, family=binomial("logit"))
tmp3
xydata=cbind(x,y)
xydata ## 100 rows, we are showing first 7
tmp1=glm(y~x, family=binomial("logit"))
tmp1
tmp3
